<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.ohgiraffers.section01.xmlmapper.ElementMapper">
    <!-- comment. Mapper.xml 파일에서 사용할 수 있는 태그 엘리먼트는 총 9가지
            <cache> , <cache-ref> , <resultMap> , <parameterMap> , <sql>
          , <select> , <insert> , <update> , <delete> -->

    <!-- comment. (외울 필요 없고 이해만 하기.)
            (첫 조회 시 DB에 다녀오고 DATA를 캐시에 저장하는데,
            이후 조회 시 DB에 다시 안 가고 캐시에 저장된 DATA를 꺼내 옴.)
            - 캐시란? 데이터나 값을 미리 복사해둔 임시의 장소를 의미한다.
            - 동일한 값을 DB에서 꺼내오는 과정을 생략하고 싶을 때 사용한다.
            - 캐시 설정은 많이 반복될 작업에 적용하는 것이 효과적이다.
            1. eviction : 캐시 알고리즘 (default 설정 → LRU)
            2. flushInterval : 설정된 캐시를 얼마나 유지할 지 밀리초로 설정
            3. size : 캐시에 저장될 객체의 수 (default 설정 → 1024)
            4. readOnly(읽기 전용) : 읽기만 가능한 경우 캐시에 저장된 데이터 변경이 되지 않음. -->
    <cache eviction="LRU" flushInterval="1000" size="512" readOnly="true"/>
        <!-- mapper 파일의 cache 작업은 위에 한 줄이면 더 할 게 없음. -->
    <select id="selectCacheTest" resultType="java.lang.String">
                        <!-- MENU_NAME은 VALCHAR(String type이므로 resultType도 맞춰준다.-->
        SELECT
            MENU_NAME
        FROM
            TBL_MENU
    </select>

    <!-- comment. ★☆★☆★☆ <resultMap> 엘리먼트 ★☆★☆★☆
            1. ★☆ DB에서 조회한 결과 데이터를 java 객체에 매핑하는 방법을 정의하는 엘리먼트 ★☆
            2. resultMap은 MyBatis에서 가장 중요하고 강력한 엘리먼트이다.
            3. JDBC의 ResultSet에서 데이터를 가져올 때 작성되었던 코드를 혁신적으로 줄여주는 역할
                (JDBC의 한계(많은 코드들)를 혁신적으로 극복)
            4. Join과 같은 매핑은 굉장히 많은 코드를 필요로 하는데 ResultMap이 효율적으로 바꿔준다. -->
    <!-- comment. resultMap의 속성
            1. id : 매핑 구문에서 결과를 매핑할 때 구분하기 위한 ID 역할
            2. type : 결과 매핑을 적용하는 대상 객체 타입(= 매핑 구문의 결과 데이터를 저장할 JAVA 타입)
            3. extends : 자바의 상속처럼 기존에 정의된 reulstMap을 상속받아 확장할 수 있다. -->
    <resultMap id="menuResultMap1" type="com.ohgiraffers.common.MenuDTO">
        <id property="code" column="MENU_CODE"/>
        <result property="name" column="MENU_NAME"/>
        <result property="price" column="MENU_PRICE"/>
        <result property="categoryCode" column="CATEGORY_CODE"/>
        <!-- orderableStatus는 menuResultMap2에서 작성 -->
    </resultMap>
    <!-- menuResultMap1(id)를 menuResultMap2의 extends에 삽입, 상속 관계가 된다. -->
    <resultMap id="menuResultMap2" type="com.ohgiraffers.common.MenuDTO" extends="menuResultMap1">
        <result property="orderableStatus" column="ORDERABLE_STATUS"/>
    </resultMap>

    <select id="selectResultMapTest" resultMap="menuResultMap2"> <!-- ResultMap1과 2 모든 속성 사용 가능 -->
        SELECT
             MENU_CODE
            ,MENU_NAME
            ,MENU_PRICE
            ,CATEGORY_CODE
            ,ORDERABLE_STATUS
        FROM
            TBL_MENU
        WHERE
            ORDERABLE_STATUS = 'Y'
    </select>
    <!-- comment. reseultMap의 하위 엘리먼트
            1. id : pk 컬럼을 매핑하기 위한 태그 엘리먼트
            2. result : pk가 아닌 컬럼을 매핑하기 위한 엘리먼트
            3. constructor : 결과를 매핑할 클래스의 생성자를 통해 매핑하기 위한 엘리먼트
            4. association : 관계가 맺어진 테이블 간의 1:1 포함 관계인 경우 사용
            5. collection : 관계가 맺어진 테이블 간의 1:M 포함 관계인 경우 사용 -->

    <!-- comment. constructor 엘리먼트
            <idArg> , <arg> 하위 엘리먼트를 가지고 있다.
            resultMap의 id , result 엘리먼트는 setter를 사용하기 때문에 property를 지정해야 한다.
            생성자를 사용해서 값을 집어넣어 주기 때문에 순서와 타입을 맞춰서 작성해야 한다.
             (ex) DTO에 첫번째 전달인자는 int형의 code이므로 db상의 column과 type도 맞춰 줘야 함.)-->
    <resultMap id="menuResultMap3" type="com.ohgiraffers.common.MenuDTO">
        <constructor>
            <idArg column="MENU_CODE" javaType="_int"/>
            <arg column="MENU_NAME" javaType="string"/>
            <arg column="MENU_PRICE" javaType="_int"/>
            <arg column="CATEGORY_CODE" javaType="_int"/>
            <arg column="ORDERABLE_STATUS" javaType="string"/>
        </constructor>
        <!-- 보통 id, result 방식을 더 많이 사용 하지만 constructor 방식도 있다~ 라고 알고 있기 -->

    </resultMap>
    <select id="selectResultMapConstructor" resultMap="menuResultMap3">
        SELECT
            *
        FROM
            TBL_MENU
        WHERE
            ORDERABLE_STATUS = 'Y'
    </select>

    <!-- comment. association (드뎌 객체 관점이어서 어려워짐, 복습 필수)
            resultMap을 구성하는 방법 1. : 따로 만든 result 이용 -->
    <!-- 여기서 CategoryDTO 생성했음 -->
    <resultMap id="categoryResultMap" type="com.ohgiraffers.common.CategoryDTO">
        <id property="code" column="CATEGORY_CODE"/>
        <result property="name" column="CATEGORY_NAME"/>
        <result property="refCategoryCode" column="REF_CATEGORY_CODE"/>
    </resultMap>

    <resultMap id="menuAndCategoryResultMap" type="com.ohgiraffers.common.MenuAndCategoryDTO">
        <id property="code" column="MENU_CODE"/>
        <result property="name" column="MENU_NAME"/>
        <result property="price" column="MENU_PRICE"/>
        <result property="orderableStatus" column="ORDERABLE_STATUS"/>
        <association property="categoryDTO" resultMap="categoryResultMap"/> <!-- 이부분 복습 -->
    </resultMap>
    <select id="selectResultMapAssociationTest" resultMap="menuAndCategoryResultMap">
        SELECT
             A.MENU_CODE
            ,A.MENU_NAME
            ,A.ORDERABLE_STATUS
            ,A.MENU_PRICE
            ,B.CATEGORY_CODE
            ,B.CATEGORY_NAME
            ,B.REF_CATEGORY_CODE
        FROM
            TBL_MENU A
            JOIN
            TBL_CATEGORY B ON (A.CATEGORY_CODE = B.CATEGORY_CODE)
        WHERE
            A.ORDERABLE_STATUS = 'Y'
    </select>

</mapper>